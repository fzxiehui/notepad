# 数据推送流程设计

## 整体流程

![datapush](/iot/datapush.svg)

## 设计说明

### 流程一: 数据推送

采集程序在完成数据解析后，通过`Redis Stream`进行数据推送。
该方案的优势主要体现在以下几个方面：

1. 数据安全与可靠性保障

    - 相比传统的`pub/sub`机制，`Redis Stream`提供了消息持久化与数据长度控制能力，可有效避免数据丢失，并根据系统需求灵活平衡性能与稳定性。

1. 良好的可扩展性与解耦能力

    - `Redis Stream`支持`Consumer Group`机制，在不修改采集程序的前提下，可扩展多写库、实时推送及事件告警等多种下游消费场景。

1. `ACK/Pending` 可靠消费机制
    
    - 消费者在处理消息前，消息会进入`Pending`状态，处理完成后通过`ACK`进行确认。
    - 未被确认的消息可被重新接管与消费，从而保障消息至少一次投递，提升系统在异常场景下的可靠性。

### 流程二：更新数据时间

系统使用`Redis ZSet`维护传感器最新数据时间戳，主要用于定时离线检测与离线告警。

1. `ZSet`以时间戳作为`score`(分数可重复)，以传感器唯一标识作为`member`，可高效完成时间排序与范围查询。

    - 通过定时任务扫描超过阈值未更新的数据项，可快速识别离线传感器并触发相应的告警逻辑。
    - 该方案实现简单、性能稳定，适用于大规模设备的周期性在线状态检测场景。

### 流程三：更新实时数据

系统使用`Redis Hash`存储传感器的实时数据快照，主要服务于`Web实时数据`展示场景。

1. `Hash`以传感器唯一标识为`key`，各数据点作为`field`存储，支持高效读写与局部更新。
实时数据可来源于多种途径，包括：

    - 系统初始化时的数据加载
    - 通过`MQTT`接收的最新上报数据
    - 其他通信协议获取的实时数据（如总召唤）

### `Redis Key`设计规范
:::tip 设计原则
- 语义清晰：`Key`名称能够直观反映数据用途
- 分层命名：采用冒号`:`进行层级划分，便于管理与监控
- 职责单一：不同数据类型（`Stream`/`ZSet`/`Hash`）职责明确，避免混用
- 可扩展性：预留业务与设备维度，支持后续系统扩展
:::

| 类型    | Key 示例                      | 数据结构         | 说明                 |
| ----- | --------------------------- | ------------ | ------------------ |
| 数据流   | `stream:sensor:data`        | `Stream`       | 传感器原始数据流，用于数据采集与分发 |
| 消费组   | `group:db_writer`           | `Stream Group` | 数据落库消费组            |
| 消费组   | `group:realtime_push`       | `Stream Group` | 实时推送消费组            |
| 时间索引  | `zset:sensor:last_ts`       | `ZSet`         | 传感器最近一次数据更新时间      |
| 实时数据  | `hash:sensor:realtime`      | `Hash`         | 传感器实时数据快照          |
| 单设备数据 | `hash:sensor:realtime:{id}` | `Hash`         | 单个传感器实时数据          |
| 告警状态  | `hash:sensor:alarm`         | `Hash`         | 传感器告警状态记录          |
